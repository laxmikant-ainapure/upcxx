"""
This is a nobs rule-file. See nobs/nobs/ruletree.puy for documentation
on the structure and interpretation of a rule-file.
"""

import os
import sys

from nobs import subexec

def env(name, otherwise):
  """
  Read `name` from the environment returning it as an integer if it
  looks like one otherwise a string. If `name` does not exist in the 
  environment then `otherwise` is returned.
  """
  try:
    got = os.environ[name]
    try: return int(got)
    except ValueError: pass
    return got
  except KeyError:
    return otherwise

def merge_libs_inplace(dst, src):
  """
  Merge the library set of `src` into `dst`.
  
  Library sets are encoded as a dictionary of the type:
    {libname:str: None | (ppflags:[str], libflags:[str])}.
  
  That is each key is the short name of the library (like 'm') and the 
  value is either None for system-installed libraries, or a tuple 
  containing the necessary preprocessor and link-time command-line 
  token lists.
  """
  for k,v in src.items():
    if dst.get(k,v) != v:
      raise Exception("Multiple '%s' libraries with differing configurations." % k)
    dst[k] = v

@cached
def output_of(cmd_args):
  """
  Returns (returncode,stdout,stderr) generated by invoking the command
  arguments as a child process.
  """
  import subprocess as sp
  p = sp.Popen(cmd_args, stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE)
  stdout, stderr = p.communicate()
  return (p.returncode, stdout, stderr)

@rule(cli='cxx')
def cxx(cxt):
  """
  String list for the C++ compiler. Defaults to g++.
  """
  return [env('CXX','g++')]

@rule(cli='cc11')
def cc(cxt):
  """
  String list for the C compiler. Defaults to gcc.
  """
  return [env('CC','gcc')]

@rule()
def lang_c11(cxt):
  """
  String list to engage C11 language dialect for the C compiler.
  """
  return ['-std=c11']

@rule()
def lang_cxx11(cxt):
  """
  String list to engage C++11 language dialect for the C++ compiler.
  """
  return ['-std=c++11']

def sanitized_output_of(cmd):
  """
  Not using this yet since it's very non-portable. Intended to strip
  paths to temporary things from the output generated by "gcc -v".
  """
  import re
  rc,out,err = output_of(cmd)
  sanitize = lambda s: re.sub(r'/tmp/[^/]*\.[^/.]+', '', s)
  return (rc, sanitize(out), sanitize(err))

@rule()
def cxx_version(cxt):
  """
  Value representing the C++ compiler identity.
  """
  cxx = cxt.cxx()
  return output_of(cxx + ['--version'])

@rule()
def cc_version(cxt):
  """
  Value representing the C compiler identity.
  """
  cc = cxt.cc()
  return output_of(cc + ['--version'])

@rule(path_arg='src')
@coroutine
def cxx11_pp(cxt, src):
  """
  File-specific C++11 compiler with preprocessor flags.
  """
  cxx11 = cxt.cxx() + cxt.lang_cxx11()
  ipt = yield cxt.include_paths_tree()
  libs = yield cxt.libraries(src)
  yield cxx11 + ['-I'+ipt] + sum(zip(*libs.values())[0], [])

@rule()
def cg_optlev(cxt):
  """
  The default code-gen optimization level for compilation. Reads the
  "OPTLEV" environment variable.
  """
  return env('OPTLEV', 2)

@rule(path_arg='src')
def cg_optlev_forfile(cxt, src):
  """
  File-specific code-gen optimization level, defaults to `cg_optlev`.
  """
  return cxt.cg_optlev()

@rule()
def cg_dbgsym(cxt):
  """
  Include debugging symbols and instrumentation in compiled files.
  """
  return env('DBGSYM', 0)

@rule(path_arg='src')
@coroutine
def cxx11_pp_cg(cxt, src):
  """
  File-specific C++11 compiler with preprocessor and code-gen flags.
  """
  cxx11_pp = yield cxt.cxx11_pp(src)
  optlev = cxt.cg_optlev_forfile(src)
  dbgsym = cxt.cg_dbgsym()
  yield cxx11_pp + ['-O%d'%optlev] + (['-g'] if dbgsym else [])

@rule(path_arg='src')
@coroutine
def compiler(cxt, src):
  """
  File-specific compiler lambda. Given a source file path, returns a
  function that given a path of where to place the object file, returns
  the argument list to invoke as a child process.
  """
  cxx11_pp_cg = yield cxt.cxx11_pp_cg(src)
  yield lambda outfile: cxx11_pp_cg + ['-c', src, '-o', outfile]

@rule()
def linker(cxt):
  """
  The linker lambda. Returns a function taking a path to the executable
  to generate as well as a list of object file paths to link together
  and returns the argument list excluding library dependency flags.
  """
  cxx = cxt.cxx()
  return lambda exe,objs: cxx + ['-o', exe] + objs

@rule()
def linker_version(cxt):
  """
  Value identifying the linker.
  """
  return cxt.cxx_version()

@rule(path_arg='src')
def libraries(cxt, src):
  """
  File-specific library set required to compile and eventually link the
  file `src`.
  """
  # Um, should be smarter. Right now everyone just depends on gasnet.
  return cxt.libgasnet()

@rule()
def gasnet_conduit(cxt):
  """
  GASNet conduit to use.
  """
  return env('GASNET_CONDUIT','smp')

@rule()
def gasnet_syncmode(cxt):
  """
  GASNet sync mode to use.
  """
  # this should be computed based off the choice of upcxx backend
  return 'seq'

@rule_memoized()
class include_paths_tree:
  """
  Setup a shim directory containing a single symlink named 'upcxx' which
  points to 'upcxx/src'. With this directory added via '-I...' to
  compiler flags, allows our headers to be accessed via:
    #include <upcxx/*.hpp>
  """
  def execute(cxt):
    return cxt.mktree({'upcxx': here('src')}, symlinks=True)

@rule_memoized(cli='incs', path_arg=0)
class includes:
  """
  Ask compiler for all the non-system headers pulled in by preprocessing
  the given source file. Returns the list of header paths.
  """
  
  @traced
  @coroutine
  def get_cxx11_pp_and_src(me, cxt, src):
    cxx11_pp = yield cxt.cxx11_pp(src)
    me.depend_files(src)
    me.depend_fact(key=None, value=cxt.cxx_version())
    yield cxx11_pp, src
  
  @coroutine
  def execute(me):
    cxx11_pp, src = yield me.get_cxx11_pp_and_src()
    cmd = cxx11_pp + ['-MM','-MT','x',src]
    
    mk = yield subexec.launch(cmd, capture_stdout=True)
    mk = mk[mk.index(":")+1:]
    
    import shlex
    deps = shlex.split(mk.replace("\\\n",""))[1:] # first is source file
    deps = map(os.path.abspath, deps)
    me.depend_files(*deps)    
    deps = map(os.path.realpath, deps)
    
    yield deps

@rule_memoized(cli='obj', path_arg=0)
class compile:
  """
  Compile the given source file. Returns path to object file.
  """
  @traced
  
  @coroutine
  def get_src_compiler(me, cxt, src):
    compiler = yield cxt.compiler(src)
    me.depend_fact(key=None, value=cxt.cxx_version())
    
    includes = yield cxt.includes(src)
    me.depend_files(src)
    me.depend_files(*includes)
    
    yield src, compiler
  
  @coroutine
  def execute(me):
    src, compiler = yield me.get_src_compiler()
    
    objfile = me.mkpath(None, suffix='.o')
    yield subexec.launch(compiler(objfile))
    yield objfile

@rule_memoized(cli='exe', path_arg=0)
class executable:
  """
  Compile the given source file as well as all source files which can
  be found as sharing its name with a header included by any source
  file reached in this process (transitively closed set). Take all those
  compiled object files and link them along with their library
  dependencies to proudce an executable. Path to executable returned.
  """
  
  @traced
  def main_src(me, cxt, main_src):
    return main_src
  
  @traced
  def do_includes(me, cxt, main_src, src):
    return cxt.includes(src)
  
  @traced
  def do_compile_and_libraries(me, cxt, main_src, src):
    return futurize(cxt.compile(src), cxt.libraries(src))
  
  @traced
  def get_linker(me, cxt, main_src):
    linker = cxt.linker()
    me.depend_fact(key=None, value=cxt.linker_version())
    return linker
  
  @traced
  def find_src_exts(me, cxt, main_src, base):
    def exists(ext):
      path = base + ext
      me.depend_files(path)
      return os.path.exists(path)
    return filter(exists, ('.c','.C','.cpp','.cxx','.c++','.C++'))
  
  @coroutine
  def execute(me):
    main_src = me.main_src()
    
    # compile object files
    incs_seen = set()
    objs = []
    libs = {}
    
    def fresh_src(src):
      return async.when_succeeded(
        me.do_includes(src) >> includes_done,
        me.do_compile_and_libraries(src) >> compile_done
      )
    
    os_path_splitext = os.path.splitext
    
    def includes_done(incs):
      tasks = []
      for inc in incs:
        inc, _ = os_path_splitext(inc)
        if inc not in incs_seen:
          incs_seen.add(inc)
          if not os.path.relpath(inc, here('src')).startswith('..' + os.path.sep):
            for ext in me.find_src_exts(inc):
              tasks.append(fresh_src(inc + ext))
      
      return async.when_succeeded(*tasks)
    
    def compile_done(obj, more_libs):
      objs.append(obj)
      merge_libs_inplace(libs, more_libs)
    
    # wait for all compilations
    yield fresh_src(main_src)
    
    # topsort library flags by library-library dependencies
    sorted_libflags = []
    sorted_libs = set()
    def topsort(xs):
      for x in xs:
        if libs.get(x) is None:
          libflags, deps = ['-l'+x], []
        else:
          _, libflags, deps = libs[x]
        
        topsort(deps)
        
        if x not in sorted_libs:
          sorted_libs.add(x)
          sorted_libflags.append(libflags)
    
    topsort(libs)
    sorted_libflags = sum(reversed(sorted_libflags), [])
    
    # link
    exe = me.mkpath('exe', suffix='.x')
    linker = yield me.get_linker()
    yield subexec.launch(linker(exe, objs) + sorted_libflags)
    
    yield exe

@rule_memoized(cli='download')
class download:
  """
  Download a file from url. Returns path to local file.
  """
  @traced
  def get_url(me, cxt, url):
    return url
  
  @coroutine
  def execute(me):
    url = me.get_url()
    dest = me.mkpath(key=url)
    
    @async.launched
    def retrieve():
      import urllib
      urllib.urlretrieve(url, dest)
    
    print>>sys.stderr, 'Downloading %s' % url 
    yield retrieve()
    print>>sys.stderr, 'Finished    %s' % url
    
    yield dest

def makefile_extract(makefile, varname):
  """
  Extract a variable's value from a makefile.
  """
  import subprocess as sp
  p = sp.Popen(['make','-f','-','gimme'], stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE)
  tmp = ('include {0}\n' + 'gimme:\n' + '\t@echo $({1})\n').format(makefile, varname)
  val, _ = p.communicate(tmp)
  if p.returncode != 0:
    raise Exception('Makefile %s not found.'%makefile)
  val = val.strip(' \t\n')
  return val

@rule_memoized(cli='libgasnet')
class libgasnet:
  """
  Download and build gasnet. Returns the library-set dictionary pertaining
  to gasnet and all of its library depdencies (see merge_libs_inplace).
  """
  @traced
  def do_download(me, cxt):
    import base64
    gasnetex_tarball_url = base64.b64decode('aHR0cDovL2dhc25ldC5sYmwuZ292L0VYL0dBU05ldC0yMDE3LjYuMC50YXIuZ3o=')
    return cxt.download(gasnetex_tarball_url)
  
  @traced
  def get_config(me, cxt):
    me.depend_fact('CC', cxt.cc_version())
    me.depend_fact('CXX', cxt.cxx_version())
    return (
      cxt.cc() + ['-O%d'%cxt.cg_optlev()],
      cxt.cxx() + ['-O%d'%cxt.cg_optlev()],
      cxt.cg_dbgsym(),
      cxt.gasnet_conduit(),
      cxt.gasnet_syncmode()
    )
  
  @coroutine
  def execute(me):
    cc, cxx, debug, conduit, syncmode = me.get_config()
    
    tgz = yield me.do_download()
    
    untar_dir = me.mkdtemp()
    build_dir = me.mkdtemp()
    install_dir = me.mkpath(key='install')
    os.makedirs(install_dir)
    
    import tarfile
    with tarfile.open(tgz) as f:
      gasnet_dir = os.path.join(untar_dir, f.members[0].name)
      f.extractall(untar_dir)
    
    env1 = dict(os.environ)
    env1['CC'] = ' '.join(cc)
    env1['CXX'] = ' '.join(cxx)
    
    print>>sys.stderr, 'Configuring GASNet...'
    yield subexec.launch(
      [os.path.join(gasnet_dir, 'configure')] +
      ['--prefix=' + install_dir] +
      (['--enable-debug'] if debug else []) +
      ['--disable-auto-conduit-detect','--enable-%s'%conduit] +
      (['--disable-seq'] if syncmode != 'seq' else []) +
      (['--disable-parsync'] if syncmode != 'parsync' else []) +
      (['--disable-par'] if syncmode != 'par' else []),
      cwd = build_dir,
      env = env1
    )
    
    print>>sys.stderr, 'Building GASNet...'
    yield subexec.launch(['make'], cwd=build_dir, env=env1)
    yield subexec.launch(['make','install'], cwd=build_dir, env=env1)
    
    makefile = os.path.join(install_dir, 'include', '%s-conduit'%conduit, '%s-%s.mak'%(conduit, syncmode))
    
    GASNET_CXXCPPFLAGS = makefile_extract(makefile, 'GASNET_CXXCPPFLAGS').split()
    GASNET_CXXFLAGS = makefile_extract(makefile, 'GASNET_CXXFLAGS').split()
    GASNET_LIBS = makefile_extract(makefile, 'GASNET_LIBS').split()
    
    yield {'gasnet': (GASNET_CXXCPPFLAGS, GASNET_LIBS, [])}

@rule(cli='run', path_arg='main_src')
@coroutine
def run(cxt, main_src, *args):
  """
  Build the executable for `main_src` and run it with the given
  argument list `args`.
  """
  exe = yield cxt.executable(main_src)
  os.execvp(exe, [exe] + map(str, args))
