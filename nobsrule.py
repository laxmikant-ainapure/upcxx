"""
This is a nobs rule-file. See nobs/nobs/ruletree.py for documentation
on the structure and interpretation of a rule-file.
"""

import os
import sys

from nobs import errorlog
from nobs import os_extra
from nobs import subexec

cxx_exts = ('.cpp','.cxx','.c++','.C','.C++')
c_exts = ('.c',)

def env(name, otherwise):
  """
  Read `name` from the environment returning it as an integer if it
  looks like one otherwise a string. If `name` does not exist in the 
  environment then `otherwise` is returned.
  """
  try:
    got = os.environ[name]
    try: return int(got)
    except ValueError: pass
    return got
  except KeyError:
    return otherwise

"""
Library sets are encoded as a dictionary of the type:
  {libname:str: {
      'ld':[str],
      'ppflags':[str],
      'cgflags':[str],
      'ldflags':[str],
      'libflags':[str],
      'deplibs':[str]
    }, ...
  }.

That is, each key is the short name of the library (like 'm') and the 
value is a dictionary containing the linker command, various flags
lists, and the list of libraries short-names it is dependent on. If
'libflags' is absent it defaults to ['-l'+libname].
"""

def libset_merge_inplace(dst, src):
  for k,v in src.items():
    if dst.get(k,v) != v:
      raise Exception("Multiple '%s' libraries with differing configurations." % k)
    dst[k] = v

def libset_merge(*libsets):
  ans = {}
  for x in libsets:
    libset_merge_inplace(ans, x)
  return ans

def libset_ld(libset):
  lds = set(tuple(x.get('ld',())) for x in libset.values())
  lds.discard(())
  if len(lds) == 0:
    return None
  if len(lds) != 1:
    raise Exception("Multiple linkers demanded:" + ''.join(map(lambda x:'\n  '+' '.join(x), lds)))
  return list(lds.pop())

def libset_flags(libset, kind):
  flags = []
  for x in libset.values():
    flags.extend(x.get(kind+'flags', []))
  return flags

@cached
def output_of(cmd_args):
  """
  Returns (returncode,stdout,stderr) generated by invoking the command
  arguments as a child process.
  """
  try:
    import subprocess as sp
    p = sp.Popen(cmd_args, stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE)
    stdout, stderr = p.communicate()
    return (p.returncode, stdout, stderr)
  except OSError as e:
    return (e.errno, None, None)

@rule(cli='cxx')
@coroutine
def cxx(cxt):
  """
  String list for the C++ compiler.
  """
  _, cross_env = yield cxt.gasnet_config()
  ans_cross = cross_env.get('CXX','').split()
  
  ans_default = []
  if env('NERSC_HOST', None) in ('cori','edison'):
    ans_default = ['CC']
  if not ans_default:
    ans_default = ['g++']
  
  ans_user = env('CXX','').split()
  
  if ans_cross and ans_user and ans_user != ans_cross:
    errorlog.warning(
      "Cross C++ compiler (%s) differs from CXX environment variable (%s)." % (
        ' '.join(ans_cross),
        ' '.join(ans_user)
      )
    )
  
  # If the cross-config script set it, use it.
  # Otherwise honor the CXX env-variable.
  # Otherwise use intelligent defaults.
  yield ans_cross or ans_user or ans_default

@rule(cli='cc')
@coroutine
def cc(cxt):
  """
  String list for the C compiler.
  """
  _, cross_env = yield cxt.gasnet_config()
  ans_cross = cross_env.get('CC','').split()
  
  ans_default = []
  if env('NERSC_HOST', None) in ('cori','edison'):
    ans_default = ['cc']
  if not ans_default:
    ans_default = ['gcc']
  
  ans_user = env('CC','').split()
  
  if ans_cross and ans_user and ans_user != ans_cross:
    errorlog.warning(
      "Cross C compiler (%s) differs from CC environment variable (%s)." % (
        ' '.join(ans_cross),
        ' '.join(ans_user)
      )
    )
  
  # If the cross-config script set it, use it.
  # Otherwise honor the CC env-variable.
  # Otherwise use intelligent defaults.
  yield ans_cross or ans_user or ans_default

@rule()
def lang_c11(cxt):
  """
  String list to engage C11 language dialect for the C compiler.
  """
  return ['-std=c11']

@rule()
def lang_cxx11(cxt):
  """
  String list to engage C++11 language dialect for the C++ compiler.
  """
  return ['-std=c++11']

@rule(path_arg='src')
@coroutine
def comp_lang(cxt, src):
  """
  File-specific compiler with source-language dialect flags.
  """
  _, ext = os.path.splitext(src)
  
  if ext in cxx_exts:
    cxx = yield cxt.cxx()
    yield cxx + cxt.lang_cxx11()
  elif ext in c_exts:
    cc = yield cxt.cc()
    yield cc + cxt.lang_c11()
  else:
    raise Exception("Unrecognized source file extension: "+src)

def version_of(cmd):
  return output_of(cmd + ['--version'])

@rule(path_arg='src')
@coroutine
def comp_version(cxt, src):
  """
  Identity string of file-specific compiler.
  """
  _, ext = os.path.splitext(src)
  
  if ext in cxx_exts:
    cxx = yield cxt.cxx()
    yield version_of(cxx)
  elif ext in c_exts:
    cc = yield cxt.cc()
    yield version_of(cc)
  else:
    raise Exception("Unrecognized source file extension: "+src)

@rule(path_arg='src')
@coroutine
def comp_lang_pp(cxt, src):
  """
  File-specific compiler with source-language and preprocessor flags.
  """
  comp = yield cxt.comp_lang(src)
  ipt = yield cxt.include_paths_tree()
  libs = yield cxt.libraries(src)
  yield (
    comp + 
    ['-D_GNU_SOURCE=1'] + # Required for full latest POSIX on some systems
    ['-I'+ipt] +
    libset_flags(libs, 'pp')
  )

# upcxx_backend is a pseudo library used to inject the
# "-DUPCXX_BACKEND=X" preprocessor flag, and to rope in gasnet.
@rule()
@coroutine
def upcxx_backend(cxt):
  upcxx = {
    'upcxx': {
      'ppflags': ['-D%s=%s'%(
          'UPCXX_BACKEND',
          env("UPCXX_BACKEND", otherwise="gasnet1_seq")
        )],
      'libflags': [],
      'deplibs': ['gasnet']
    }
  }
  
  gasnet = yield cxt.gasnet()
  
  yield libset_merge(gasnet, upcxx)

@rule()
def cg_optlev_default(cxt):
  """
  The default code-gen optimization level for compilation. Reads the
  "OPTLEV" environment variable.
  """
  return env('OPTLEV', 2)

@rule(path_arg='src')
def cg_optlev(cxt, src):
  """
  File-specific code-gen optimization level, defaults to `cg_optlev_default`.
  """
  return cxt.cg_optlev_default()

@rule()
def cg_dbgsym(cxt):
  """
  Include debugging symbols.
  """
  return env('DBGSYM', 0)

@rule(path_arg='src')
@coroutine
def comp_lang_pp_cg(cxt, src):
  """
  File-specific compiler with language, preprocessor, and code-gen flags.
  """
  comp = yield cxt.comp_lang_pp(src)
  optlev = cxt.cg_optlev(src)
  dbgsym = cxt.cg_dbgsym()
  libset = yield cxt.libraries(src)
  
  yield (
    comp +
    ['-O%d'%optlev] +
    (['-g'] if dbgsym else []) +
    ['-Wall'] +
    libset_flags(libset, 'cg')
  )

@rule(path_arg='src')
@coroutine
def compiler(cxt, src):
  """
  File-specific compiler lambda. Given a source file path, returns a
  function that given a path of where to place the object file, returns
  the argument list to invoke as a child process.
  """
  comp = yield cxt.comp_lang_pp_cg(src)
  
  yield lambda outfile: comp + ['-c', src, '-o', outfile]

# Rule overriden in sub-nobsrule files.
@rule(cli='requires_gasnet', path_arg='src')
def requires_gasnet(cxt, src):
  return False

# Rule overriden in sub-nobsrule files.
@rule(cli='requires_upcxx_backend', path_arg='src')
def requires_upcxx_backend(cxt, src):
  return False

@rule(path_arg='src')
@coroutine
def libraries(cxt, src):
  """
  File-specific library set required to compile and eventually link the
  file `src`.
  """
  if cxt.requires_gasnet(src):
    maybe_gasnet = yield cxt.gasnet()
  else:
    maybe_gasnet = {}
  
  if cxt.requires_upcxx_backend(src):
    maybe_upcxx_backend = yield cxt.upcxx_backend()
  else:
    maybe_upcxx_backend = {}
  
  yield cxt.libset_merge(maybe_gasnet, maybe_upcxx_backend)

@rule(cli='gasnet_conduit')
def gasnet_conduit(cxt):
  """
  GASNet conduit to use.
  """
  if env('CROSS','').startswith('cray-aries-'):
    default = 'aries'
  else:
    default = 'smp'
  
  return env('GASNET_CONDUIT', default)

@rule(cli='gasnet_syncmode')
def gasnet_syncmode(cxt):
  """
  GASNet sync-mode to use.
  """
  # this should be computed based off the choice of upcxx backend
  return 'seq'

@rule_memoized()
class include_paths_tree:
  """
  Setup a shim directory containing a single symlink named 'upcxx' which
  points to 'upcxx/src'. With this directory added via '-I...' to
  compiler flags, allows our headers to be accessed via:
    #include <upcxx/*.hpp>
  """
  def execute(cxt):
    return cxt.mktree({'upcxx': here('src')}, symlinks=True)

@rule_memoized(cli='incs', path_arg=0)
class includes:
  """
  Ask compiler for all the non-system headers pulled in by preprocessing
  the given source file. Returns the list of header paths.
  """
  @traced
  @coroutine
  def get_comp_pp_and_src(me, cxt, src):
    me.depend_files(src)
    
    version = yield cxt.comp_version(src)
    me.depend_fact(key=None, value=version)
    
    comp_pp = yield cxt.comp_lang_pp(src)
    yield comp_pp, src
  
  @coroutine
  def execute(me):
    comp_pp, src = yield me.get_comp_pp_and_src()
    
    # See here for getting this to work with other compilers:
    #  https://projects.coin-or.org/ADOL-C/browser/trunk/autoconf/depcomp?rev=357
    cmd = comp_pp + ['-MM','-MT','x',src]
    
    mk = yield subexec.launch(cmd, capture_stdout=True)
    mk = mk[mk.index(":")+1:]
    
    import shlex
    deps = shlex.split(mk.replace("\\\n",""))[1:] # first is source file
    deps = map(os.path.abspath, deps)
    me.depend_files(*deps)
    deps = map(os.path.realpath, deps)
    
    yield deps

@rule_memoized(cli='obj', path_arg=0)
class compile:
  """
  Compile the given source file. Returns path to object file.
  """
  @traced
  @coroutine
  def get_src_compiler(me, cxt, src):
    compiler = yield cxt.compiler(src)
    version = yield cxt.comp_version(src)
    
    me.depend_fact(key='compiler', value=version)
    
    includes = yield cxt.includes(src)
    me.depend_files(src)
    me.depend_files(*includes)
    
    yield src, compiler
  
  @coroutine
  def execute(me):
    src, compiler = yield me.get_src_compiler()
    
    objfile = me.mkpath(None, suffix=os.path.basename(src)+'.o')
    yield subexec.launch(compiler(objfile))
    yield objfile

@rule_memoized(cli='exe', path_arg=0)
class executable:
  """
  Compile the given source file as well as all source files which can
  be found as sharing its name with a header included by any source
  file reached in this process (transitively closed set). Take all those
  compiled object files and link them along with their library
  dependencies to proudce an executable. Path to executable returned.
  """
  @traced
  def main_src(me, cxt, main_src):
    return main_src
  
  @traced
  def cxx(me, cxt, main_src):
    return cxt.cxx()
  
  @traced
  def do_includes(me, cxt, main_src, src):
    return cxt.includes(src)
  
  @traced
  def do_compile_and_libraries(me, cxt, main_src, src):
    return futurize(cxt.compile(src), cxt.libraries(src))
  
  @traced
  def find_src_exts(me, cxt, main_src, base):
    def exists(ext):
      path = base + ext
      me.depend_files(path)
      return os_extra.exists(path)
    srcs = filter(exists, c_exts + cxx_exts)
    return srcs
  
  @coroutine
  def execute(me):
    main_src = me.main_src()
    
    # compile object files
    incs_seen = set()
    objs = []
    libset = {}
    
    def fresh_src(src):
      return async.when_succeeded(
        me.do_includes(src) >> includes_done,
        me.do_compile_and_libraries(src) >> compile_done
      )
    
    os_path_splitext = os.path.splitext
    os_path_relpath = os.path.relpath
    src_dir = here('src')
    dot_dot_slash = '..' + os.path.sep
    
    def includes_done(incs):
      tasks = []
      for inc in incs:
        inc, _ = os_path_splitext(inc)
        if inc not in incs_seen:
          incs_seen.add(inc)
          if not os_path_relpath(inc, src_dir).startswith(dot_dot_slash):
            for ext in me.find_src_exts(inc):
              tasks.append(fresh_src(inc + ext))
      
      return async.when_succeeded(*tasks)
    
    def compile_done(obj, more_libs):
      objs.append(obj)
      libset_merge_inplace(libset, more_libs)
    
    # wait for all compilations
    yield fresh_src(main_src)
    
    # topsort library flags by library-library dependencies
    sorted_libflags = []
    sorted_libs = set()
    def topsort(xs):
      for x in xs:
        rec = libset.get(x, {})
        libflags = rec.get('libflags', ['-l'+x])
        deplibs = rec.get('deplibs', [])
        
        topsort(deplibs)
        
        if x not in sorted_libs:
          sorted_libs.add(x)
          sorted_libflags.append(libflags)
    
    topsort(libset)
    sorted_libflags = sum(reversed(sorted_libflags), [])
    
    # link
    exe = me.mkpath('exe', suffix='.x')
    
    ld = libset_ld(libset)
    cxx = yield me.cxx()
    if ld is None:
      ld = cxx
    ld = [cxx[0]] + ld[1:] 
    
    ldflags = libset_flags(libset, 'ld')
    
    yield subexec.launch(
      ld + ldflags + ['-o',exe] + objs + sorted_libflags
    )
    
    yield exe

@rule_memoized(cli='download')
class download:
  """
  Download a file from url. Returns path to local file.
  """
  @traced
  def get_url(me, cxt, url):
    return url
  
  @coroutine
  def execute(me):
    url = me.get_url()
    dest = me.mkpath(key=url)
    
    @async.launched
    def retrieve():
      import urllib
      urllib.urlretrieve(url, dest)
    
    print>>sys.stderr, 'Downloading %s' % url 
    yield retrieve()
    print>>sys.stderr, 'Finished    %s' % url
    
    yield dest

@rule_memoized()
class gasnet_source:
  """
  Download and extract gasnet source tree.
  """
  gasnetex_tgz_url_b64 = 'aHR0cDovL2dhc25ldC5sYmwuZ292L0VYL0dBU05ldC0yMDE3LjYuMC50YXIuZ3o='
  
  unique_id = gasnetex_tgz_url_b64
  
  @coroutine
  def execute(me):
    import base64
    gasnetex_tgz_url = base64.b64decode(me.gasnetex_tgz_url_b64)
    
    tgz = me.mktemp()
    
    @async.launched
    def download():
      import urllib
      urllib.urlretrieve(gasnetex_tgz_url, tgz)
    
    print>>sys.stderr, 'Downloading %s' % gasnetex_tgz_url 
    yield download()
    print>>sys.stderr, 'Finished    %s' % gasnetex_tgz_url
    
    untar_dir = me.mkpath(key=None)
    os.makedirs(untar_dir)
    
    import tarfile
    with tarfile.open(tgz) as f:
      source_dir = os.path.join(untar_dir, f.members[0].name)
      f.extractall(untar_dir)
    
    yield source_dir

@rule_memoized()
class gasnet_config:
  """
  Returns (argv:list, env:dict) pair corresponding to the context
  in which gasnet's other/contrib/cross-configure-{xxx} script runs
  configure.
  """
  
  @traced
  @coroutine
  def get_cross_and_gasnet_src(me, cxt):
    cross = env('CROSS', None)
    external = env('GASNET', None)
    
    if cross and external:
      raise errorlog.LoggedError(
        'Configuration Error',
        'Only one of `CROSS` and `GASNET` may be set.'
      )
    
    gasnet_src = None
    if cross:
      gasnet_src = yield cxt.gasnet_source()
    
    yield (cross, gasnet_src)
  
  @traced
  def touch_env(me, cxt, *names):
    """Place dependendcies on environment variables."""
    for name in names:
      me.depend_fact(key=name, value=env(name, None))
  
  @coroutine
  def execute(me):
    cross, gasnet_src = yield me.get_cross_and_gasnet_src()
    
    if cross is None:
      yield ([], {})
      return
    
    # add "canned" env-var dependencies of scripts here
    if cross == 'cray-aries-slurm':
      me.touch_env('SRUN')
    elif cross == 'bgq':
      me.touch_env('USE_GCC','USE_CLANG')
    
    path = os.path.join
    crosslong = 'cross-configure-' + cross
    crosspath = path(gasnet_src, 'other', 'contrib', crosslong)
    
    if not os_extra.exists(crosspath):
      raise errorlog.LoggedError('Configuration Error', 'Invalid GASNet cross-compile script name (%s).'%cross)
    
    # Create a shallow copy of the gasnet source tree minus the
    # "configure" file.
    tmpd = me.mkdtemp()
    os_extra.mktree(
      tmpd,
      dict([
          (x, path(gasnet_src, x))
          for x in os_extra.listdir(gasnet_src)
          if x != 'configure'
        ] +
        [(crosslong, crosspath)]
      ),
      symlinks=True
    )
    
    # Add our own shim "configure" which will reap the command line args
    # and environment variables and punt them back to stdout.
    with open(path(tmpd, 'configure'), 'w') as f:
      f.write(
"""#!/usr/bin/env python
import os
import sys
sys.stdout.write(repr((sys.argv, os.environ)))
""")
    import stat
    os.chmod(path(tmpd, 'configure'), 0777)
    
    # Run the cross-configure script.
    import subprocess as subp
    p = subp.Popen([path(tmpd, crosslong)], cwd=tmpd, stdout=subp.PIPE, stdin=subp.PIPE, stderr=subp.STDOUT)
    out, _ = p.communicate('')
    if p.returncode != 0:
      raise errorlog.LoggedError('Configuration Error', 'GASNet cross-compile script (%s) failed.'%cross)
    argv, env = eval(out)
    
    # Skip the first argument since that's just "configure".
    argv = argv[1:]
    
    # Only record the environment delta.
    keep = ('CC','CXX','HOST_CC','HOST_CXX',
            'MPI_CC','MPI_CFLAGS','MPI_LIBS','MPIRUN_CMD')
    env0 = os.environ
    for x in env0:
      if x in keep: continue
      if x.startswith('CROSS_'): continue
      if x not in env: continue
      if env[x] != env0[x]: continue
      del env[x]
    
    yield (argv, env)

@rule_memoized()
class gasnet_configured:
  """
  Configure gasnet build directory.
  """
  @traced
  @coroutine
  def get_config(me, cxt):
    cc = yield cxt.cc()
    cc_ver = version_of(cc)
    me.depend_fact(key='CC', value=cc_ver)
    
    cxx = yield cxt.cxx()
    cxx_ver = version_of(cxx)
    me.depend_fact(key='CXX', value=cxx_ver)
    
    config = yield cxt.gasnet_config()
    
    yield (cc, cxx, cxt.cg_optlev_default(), cxt.cg_dbgsym(), config)
  
  @traced
  def get_source_dir(me, cxt):
    return cxt.gasnet_source()
  
  @coroutine
  def execute(me):
    cc, cxx, optlev, debug, config = yield me.get_config()
    config_args, config_env = config
    
    source_dir = yield me.get_source_dir()
    
    build_dir = me.mkpath(key=None)
    os.makedirs(build_dir)
    
    env1 = dict(os.environ)
    env1.update(config_env)
    
    if 'CC' not in env1:
      env1['CC'] = ' '.join(cc + ['-O%d'%optlev])
    if 'CXX' not in env1:
      env1['CXX'] = ' '.join(cxx + ['-O%d'%optlev])
    
    misc_conf_opts = [
      # disable non-EX conduits to prevent configure failures when that hardware is detected
      '--disable-psm','--disable-mxm','--disable-portals4','--disable-ofi',
    ]
    
    print>>sys.stderr, 'Configuring GASNet...'
    yield subexec.launch(
      [os.path.join(source_dir, 'configure')] +
      config_args +
      (['--enable-debug'] if debug else []) +
      misc_conf_opts,
      
      cwd = build_dir,
      env = env1
    )
    
    yield build_dir

@rule_memoized(cli='gasnet')
class gasnet:
  """
  Build gasnet. Return library dependencies dictionary.
  """
  @traced
  def get_config(me, cxt):
    external = env('GASNET', None)
    return futurize(
      cxt.gasnet_conduit(),
      cxt.gasnet_syncmode(),
      external,
      external or cxt.gasnet_configured()
    )
  
  @coroutine
  def execute(me):
    conduit, syncmode, external, build_dir = yield me.get_config()
    
    if not external:
      print>>sys.stderr, 'Building GASNet (conduit=%s, threading=%s)...'%(conduit, syncmode)
      yield subexec.launch(
        ['make', syncmode],
        cwd = os.path.join(build_dir, '%s-conduit'%conduit)
      )
      
    makefile = os.path.join(
      build_dir,
      '%s-conduit'%conduit,
      '%s-%s.mak'%(conduit, syncmode)
    )
    
    GASNET_LD = makefile_extract(makefile, 'GASNET_LD').split()
    GASNET_LDFLAGS = makefile_extract(makefile, 'GASNET_LDFLAGS').split()
    GASNET_CXXCPPFLAGS = makefile_extract(makefile, 'GASNET_CXXCPPFLAGS').split()
    GASNET_CXXFLAGS = makefile_extract(makefile, 'GASNET_CXXFLAGS').split()
    GASNET_LIBS = makefile_extract(makefile, 'GASNET_LIBS').split()
    
    yield {
      'gasnet': {
        'ld': GASNET_LD,
        'ldflags': GASNET_LDFLAGS,
        'ppflags': GASNET_CXXCPPFLAGS,
        'cgflags': GASNET_CXXFLAGS,
        'libflags': GASNET_LIBS,
        'deplibs': []
      }
    }

def makefile_extract(makefile, varname):
  """
  Extract a variable's value from a makefile.
  """
  import subprocess as sp
  p = sp.Popen(['make','-f','-','gimme'], stdin=sp.PIPE, stdout=sp.PIPE, stderr=sp.PIPE)
  tmp = ('include {0}\n' + 'gimme:\n' + '\t@echo $({1})\n').format(makefile, varname)
  val, _ = p.communicate(tmp)
  if p.returncode != 0:
    raise Exception('Makefile %s not found.'%makefile)
  val = val.strip(' \t\n')
  return val

@rule(cli='run', path_arg='main_src')
@coroutine
def run(cxt, main_src, *args):
  """
  Build the executable for `main_src` and run it with the given
  argument list `args`.
  """
  exe = yield cxt.executable(main_src)
  os.execvp(exe, [exe] + map(str, args))
