#
# Top-level Makefile, minus the configuration variables
#

SHELL = /bin/bash
DST =

default: all ; @: # empty rule

force:

MAKEFLAGS += --no-print-directory

# Echo an arbitrary make/environment variable
echovar: force; @echo $(VARNAME)=\"$($(VARNAME))\"

# To prevent application of pass-through rule upon 'include':
Makefile $(upcxx_src)/bld/Makefile.rules: ; @: # empty rule
$(upcxx_src)/bld/%.mak: ; @: # empty rule

BLDDIR = $(upcxx_bld)/bld
GASNET_BLDDIR = $(BLDDIR)/gasnet.$(firstword $(UPCXX_DBGOPT))

include $(upcxx_src)/bld/gasnet.mak
CONDUITS  = $(call GASNET_VAR,$(GASNET_BLDDIR),CONDUITS)
EXESUFFIX = $(call GASNET_VAR,$(GASNET_BLDDIR),EXESUFFIX)

install-hook: force
	@CONDUITS='$(CONDUITS)';                             \
	 cd $(upcxx_src) &&                                  \
	 . utils/install-common.sh &&                        \
	 conduit_default="$$GASNET_CONDUIT" &&               \
	 install_to="$(prefix)" install_common

install install-opt install-debug: force
	@$(MAKE) -C $(BLDDIR) $@ || $(MAKE) failure TARGET=installation
	@$(MAKE) install-hook || $(MAKE) failure TARGET=installation
	@echo; \
	 echo 'UPC++ installation complete.'; \
	 echo 'Recommended next steps:'; \
	 echo '  See "Post-install recommendations" in'; \
	 echo '  $(upcxx_src)/INSTALL.md'

all all-opt all-debug: force
	@$(MAKE) -C $(BLDDIR) $@ || $(MAKE) failure TARGET=build
	@echo; \
	 echo 'UPC++ build complete.';    \
	 echo 'Recommended next steps:';  \
	 echo "  1. '$(GMAKE_SHORT) check'";    \
	 echo "  2. '$(GMAKE_SHORT) install'"

distclean-hook: force
	-[[ $(upcxx_src) = $(upcxx_bld) ]] || rm -R $(BLDDIR)/Makefile
	-rm -Rf $(upcxx_bld)/Makefile $(upcxx_bld)/bin/upcxx $(upcxx_bld)/bin/upcxx-run $(upcxx_bld)/bin/upcxx-meta $(GASNET_UNPACKED)

distclean: force
	@$(MAKE) -C $(BLDDIR) $@
	@$(MAKE) $@-hook

EXE_VPATH = "$(upcxx_src)/test" "$(upcxx_src)/example" "$(upcxx_src)/bench"
exe run: force
	@if test -z "$(SRC)"; then \
	    echo "ERROR: target '$@' requires a SRC" >&2; \
	    echo "example: 'make $@ SRC=test/hello_upcxx.cpp'" >&2; \
	    exit 1; \
	 fi
	@src=$(SRC);                                                   \
	 if [[ ! -f "$(SRC)" && "$(SRC)" != /* ]]; then                \
	   for d in $$(find $(EXE_VPATH) -type d); do                  \
	     if [[ -f "$$d/$(SRC)" ]]; then                            \
	       src="$$d/$(SRC)"; break;                                \
	     fi                                                        \
	   done;                                                       \
	   if [[ -z "$$src" ]]; then                                   \
	    echo "ERROR: file SRC='$(SRC)' does not exist" >&2;        \
	    exit 1;                                                    \
	   fi                                                          \
	 fi;                                                           \
	 $(MAKE) -C $(BLDDIR) $@ SRC="$$src" STARTDIR="$(shell pwd)"

# Default is pass-through
# TODO?: HOOK and LOCAL "magic" like UPCR's multiconf
%: force; @$(MAKE) -C $(BLDDIR) $@

failure: force
	@echo -e '\n********\nUPC++ $(TARGET) failed. Please report the ENTIRE log above to: upcxx@googlegroups.com\n********\n' >&2
	@exit 1

.PHONY: force echovar failure
.PHONY: install install-hook
.PHONY: distclean distclean-hook
.PHONY: exe run

## Tests ##
include $(upcxx_src)/bld/tests.mak

# public-facing targets don't use GASNet "conduit" terminology
NETWORKS ?= $(CONDUITS)

# Pick 'debug' for building tests, unless --enable-single=opt
ifeq ($(strip $(UPCXX_DBGOPT)),opt)
UPCXX_TESTS_CODEMODE = O3
UPCXX_TESTS_GASNET   = opt
else
UPCXX_TESTS_CODEMODE = debug
UPCXX_TESTS_GASNET   = debug
endif

# Compile prerequisites for 'check' or 'tests'
# Build is restricted to single codemode and the networks in $(NETWORKS)
do-test-prereqs: force
	@$(MAKE) -C $(BLDDIR) GASNET_CONDUITS="$(NETWORKS)" do-upcxx-all-$(UPCXX_TESTS_GASNET) || \
         $(MAKE) failure TARGET=build

.PHONY: do-test-prereqs

# Compile and run tests for default conduit
check: force
	@$(MAKE) do-test-prereqs NETWORKS=$(GASNET_CONDUIT)
	@echo; \
	 echo '************'; \
	 echo 'Compiling and running tests for the default network ($(GASNET_CONDUIT)).'; \
	 echo 'Please, ensure you are in a proper environment for launching parallel jobs'; \
	 echo '(eg batch system session, if necessary) or the run step may fail.'; \
	 echo '************'; \
	 echo ; sleep 5
	@$(MAKE) do-tests do-run-tests UPCXX_BINDIR=$(upcxx_bld)/bin UPCXX_QUIET=1 NETWORKS=$(GASNET_CONDUIT) UPCXX_SKIP_REBUILD=1
	@echo 'Recommended next steps:';  \
	 echo "  If you have not already, you may now '$(GMAKE_SHORT) install'"

.PHONY: check

# Build UPCXX_TESTS (default all)
# UPCXX_CODEMODE is 'debug' if supported
# Default network (if included in NETWORKS) is built last to keep it on user's screen
do-tests: force
	@total=0; failed=0;                                  \
	 export UPCXX_CODEMODE=$(UPCXX_TESTS_CODEMODE);      \
	 if [[ -n '$(UPCXX_TESTS)' ]]; then                  \
	   testlist='$(UPCXX_TESTS)';                        \
	 else                                                \
	   testlist='$(addsuffix -seq,$(testprograms_seq)) $(addsuffix -par,$(testprograms_par))' ; \
	 fi;                                                 \
	 for network in $(filter-out $(GASNET_CONDUIT),$(NETWORKS)) \
                        $(filter $(GASNET_CONDUIT),$(NETWORKS)); do \
	   export UPCXX_NETWORK=$$network;                   \
	   for test in $$testlist; do                        \
	     export UPCXX_THREADMODE=$${test/*-/};           \
	     file=$${test%-*};                               \
	     target="test-$$(basename $$file .cpp)-$$network";\
	     printf 'Compiling %-30s ' "$$target...";        \
	     $(UPCXX_BINDIR)/upcxx $(upcxx_src)/test/$$file  \
	                           -o $$target$(EXESUFFIX);  \
	     if [[ $$? != 0 ]]; then                         \
	       echo FAILED; : $$((++failed));                \
	     else                                            \
	       echo SUCCESS;                                 \
	     fi;                                             \
	     : $$((++total));                                \
	   done;                                             \
	 done;                                               \
	 if [[ $$failed = 0 ]]; then                         \
	   echo "PASSED compiling $$total tests";            \
	 else                                                \
	   echo "FAILED to compile $$failed of $$total tests";\
	 fi;                                                 \
	 [[ $$failed = 0 ]] # exit code

do-test-msg = \
	@echo ' '; \
	 echo '       ==== UPC++ TESTS SUCCESSFULLY COMPILED ===='; \
	 echo ' '; \
	 echo 'Your UPC++ $(1) appears to be working for the following networks:'; \
	 echo ' '; \
	 echo '  $(NETWORKS)'; \
	 echo ' '; \
	 echo 'You may now test UPC++ runtime operation for each network of interest.'; \
	 echo 'First, ensure you are in a proper environment for launching parallel jobs'; \
	 echo '(eg batch system session, if necessary) and then issue a command like:'; \
	 echo ' '; \
	 echo '  $(2)/upcxx-run -n 2 ./test-hello_upcxx-$(GASNET_CONDUIT)'; \
	 echo ' '; \
	 echo -e 'And similarly for any other of the tests compiled above.'

test_install: force
	@if [[ ! -x $(prefix)/bin/upcxx-run ]]; then \
	   echo 'ERROR: No UPC++ installation found at $(prefix)'; \
	   echo "ERROR: Please build the 'install' target before 'test_install'."; \
	   exit 1; \
	 fi
	@$(MAKE) do-tests UPCXX_BINDIR=$(prefix)/bin UPCXX_TESTS=hello_upcxx.cpp-seq
	@$(call do-test-msg,install,$(prefix)/bin)

tests: force
	@$(MAKE) do-test-prereqs
	@$(MAKE) do-tests UPCXX_BINDIR=$(upcxx_bld)/bin UPCXX_QUIET=1 UPCXX_SKIP_REBUILD=1
	@$(call do-test-msg,build,$(upcxx_bld)/bin)

ALL_TESTS = $(foreach test, $(notdir $(testprograms_seq) $(testprograms_par)), \
            $(foreach network, $(1), test-$(basename $(test))-$(network)))

tests-clean: force
	rm -f $(call ALL_TESTS,$(ALL_CONDUITS))

.PHONY: do-tests do-test-msg test_install tests tests-clean

do-run-tests: force
	@tmpfile=.testtmp_$$$$; rm -f $$tmpfile;                        \
	 if [[ -z "$(RANKS)" ]]; then ranks=4; else ranks=$(RANKS); fi; \
	 total=0; failed=0;                                             \
	 echo "Running tests with $$ranks ranks";                       \
	 for test in $(call ALL_TESTS,$(NETWORKS)); do                  \
	   [[ -x $$test ]] || continue;                                 \
	   echo "Running $$test"; : $$((++total));                      \
	   $(UPCXX_BINDIR)/upcxx-run -np $$ranks ./$$test &> $$tmpfile; \
	   if [[ $$? != 0 ]] || grep -q ERROR $$tmpfile; then           \
	     echo FAILED; : $$((++failed));                             \
	   fi;                                                          \
	   grep "Test result: " $$tmpfile | sort -u;                    \
	 done;                                                          \
	 rm -f $$tmpfile;                                               \
	 if [[ $$failed = 0 ]]; then                                    \
	   echo "PASSED running $$total tests";                         \
	 else                                                           \
	   echo "FAILED running $$failed of $$total tests";             \
	   $(MAKE) failure TARGET=tests;                                \
	 fi;                                                            \
	 [[ $$failed = 0 ]] # exit code

run-tests: force
	@$(MAKE) do-run-tests UPCXX_BINDIR=$(upcxx_bld)/bin UPCXX_QUIET=1

run-tests-installed: force
	@$(MAKE) do-run-tests UPCXX_BINDIR=$(prefix)/bin

.PHONY: do-run-tests run-tests run-tests-installed

.NOTPARALLEL:
